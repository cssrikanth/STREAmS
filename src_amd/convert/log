
CONFIGURABLE GPUFORT OPTIONS (DEFAULT VALUES):

---- gpufort -----------------------------
__GPUFORT_INC_DIR                   = os.path.join(os.path.dirname(os.path.realpath(__file__)),"../include")
INCLUDE_DIRS                        = [ __GPUFORT_INC_DIR ]
        # Include dir for gpufort_mod file and header files.
POST_CLI_ACTIONS                    = [] 
       # List of actions to run after parsing the command line arguments
       # Note that config is read before parsing other command line arguments.
       # Register functions with parameters (args,unknown_args) (see: argparse.parse_known_args
# logging
LOG_LEVEL                           = "warning"
        # Log level; only print warnings by default.
LOG_FORMAT                          = "[%(levelname)s][infile:%(filename)s] gpufort:%(message)s"
        # Log format
LOG_PREFIX                          = "gpufort"
        # Prefix for all log output
ONLY_CREATE_GPUFORT_MODULE_FILES    = False
        # Only create and write GPUFORT module files and no other output.
SKIP_CREATE_GPUFORT_MODULE_FILES    = False 
        # Skip creating and writing GPUFORT module files.
ONLY_MODIFY_TRANSLATION_SOURCE      = False
        # Do only modify the translation source. 
ONLY_EMIT_KERNELS_AND_LAUNCHERS     = False
        # Do only emit/extract HIP C++ kernels and respective launchers. (Only makes sense if destination language is HIP.)
ONLY_EMIT_KERNELS                   = False
        # Do only emit/extract HIP C++ kernels but no launchers. (Only makes sense if destination language is HIP.)
MODIFIED_FILE_EXT                   = "-gpufort.f08"
       # Suffix for the modified file.
PRETTIFY_MODIFIED_TRANSLATION_SOURCE= False 
        # Prettify the translation source after all modifications have been applied.
        # (Does not change the actual source but the modified version of it.)
PROFILING_ENABLE                    = False
        # Enable profiling of GPUFORT
PROFILING_OUTPUT_NUM_FUNCTIONS      = 50
        # Number of functions to output when profiling GPUFORT

---- scanner -----------------------------
scanner.LOG_PREFIX                  = "scanner.scanner" # log prefix
scanner.TRANSLATION_ENABLED_BY_DEFAULT= True
scanner.SOURCE_DIALECTS             = ["cuf","acc"] # one of ["acc","cuf","omp"]
scanner.DESTINATION_DIALECT         = "omp"         # one of ["omp","hip-runtime-rt"]
scanner.KERNELS_TO_CONVERT_TO_HIP   = [] # add line number here (might change if snippets are included included); check log to find actual line number
scanner.LOOP_VARIABLES              = "integer :: {}".format(",".join(["_"+chr(ord("a")+i) for i in range(0,20) ])) # integer :: _a,_b,_c,_d,...
scanner.GLOBAL_DECLARATIONS         = [ LOOP_VARIABLES ] # TODO check if this still works
scanner.LOOP_KERNEL_NAME_TEMPLATE   = "{parent}_{lineno}_{hash}" # parent: name of parent module,program,subroutine (lower case)
                                                    # lineno: line number
                                                    # hash: Hash of the kernel (whitespaces are removed beforehand)
scanner.LOOP_KERNEL_DEFAULT_LAUNCHER= "auto" # "auto" or "cpu"
scanner.HIP_MODULE_NAME             = "hipfort"
scanner.HIP_MATH_MODULE_PREFIX      = HIP_MODULE_NAME+"_"
scanner.CUDA_IFDEF                  = "CUDA"
scanner.CUBLAS_VERSION              = 1
scanner.KEEP_CUDA_LIB_NAMES         = False
scanner.ACC_DEV_PREFIX              = "dev_"
scanner.ACC_DEV_SUFFIX              = ""
scanner.LINE_GROUPS_ENABLE          = True # group modified lines such that they appear in the block when wrapping them in ifdefs.
scanner.LINE_GROUPS_INCLUDE_BLANK_LINES= True # Include intermediate blank lines into a line group.
---- translator -----------------------------
# general options
translator.LOG_PREFIX               = "translator.translator"
translator.COMMENT                  = r"(!|^\s*[\*cCdD])[^\$].+"
translator.KEYWORD_CASE             = "lower" # one of ["lower","upper","camel"]
translator.CHARACTER_FORMAT         = "{type}({len})"  
    # Format to use when generating Fortran character datatype
translator.DERIVED_TYPE_FORMAT      = "{type}({kind})" 
    # Format to use when generating datatype part of Fortran derived type variable
translator.BASIC_TYPE_FORMAT        = "{type}({kind})" 
    # Format to use when generating Fortran basic datatype such as integer/real/... types.
translator.GPUFORT_CPP_SYMBOLS      = {
  "threadidx.x" : "(1+threadIdx.x)",
  "threadidx.y" : "(1+threadIdx.y)",
  "threadidx.z" : "(1+threadIdx.z)",
  "blockidx.x"  : "(1+blockIdx.x)",
  "blockidx.y"  : "(1+blockIdx.y)",
  "blockidx.z"  : "(1+blockIdx.z)",
  "blockdim.x"  : "blockDim.x",
  "blockdim.y"  : "blockDim.y",
  "blockdim.z"  : "blockDim.z",
  "griddim.x"   : "gridDim.x",
  "griddim.y"   : "gridDim.y",
  "griddim.z"   : "gridDim.z",
  "warpsize"    : "warp_size",
  "syncthreads" : "__syncthreads",
  "atomicadd"   : "atomicAdd",
  "atomicsub"   : "atomicSub",
  "atomicmax"   : "atomicMax",
  "atomicmin"   : "atomicMin",
  "atomicand"   : "atomicAnd",
  "atomicor"    : "atomicOr",
  "atomicxor"   : "atomicXor",
  "atomicexch"  : "atomicExch",
  "atomicinc"   : "atomicInc",
  "atomicdec"   : "atomicDec",
  "atomiccas"   : "atomicCas",
  "sign"        : "copysign",
  # symbols generated by GPUFORT
  "__pow"       : "pow",
}
    # lower case C-like symbols generated from Fortran code and their translation to HIP C++ (device) symbols
translator.MAX_DIRECTIVE_LINE_WIDTH = 80
translator.UNCONVERTED              = "TODO(gpufort) UNCONVERTED - Please adjust yourself!"
translator.DEPEND_TODO              = "TODO(gpufort) - specify depend inputs"
translator.FORTRAN_2_C_TYPE_MAP     = { 
  "character": {
    "": "char",
    "c_char": "char"
  },
  "complex" : { 
    "": "hipFloatComplex",
    "16": None,
    "8": "hipDoubleComplex",
    "4": "hipFloatComplex",
    "2": None,
    "1": None,
    "c_float_complex": "hipFloatComplex",
    "c_double_complex": "hipDoubleComplex",
    "c_long_double_complex": "long double _complex"
  },
  "doubleprecision" : {
    "":"double"
  },
  "real" : { 
    "": "float",
    "16": "long double",
    "8": "double",
    "4": "float",
    "2": "_Float16",
    "1": None,
    "c_float": "float",
    "c_double": "double",
    "c_long_double": "long double",
    "c_float128": "__float128",
    "c_float128_complex": "__float128 _complex"
  },
  "integer" : { 
    "": "int",
    "8": "long",
    "4": "int",
    "2": "short",
    "1": "char",
    "c_int": "int",
    "c_short": "short int",
    "c_long": "long int",
    "c_long_long": "long long int",
    "c_signed_char": "signed char",
    "c_size_t": "size_t",
    "c_int8_t": "int8_t",
    "c_int16_t": "int16_t",
    "c_int32_t": "int32_t",
    "c_int64_t": "int64_t",
    "c_int128_t": "int128_t",
    "c_int_least8_t": "int_least8_t",
    "c_int_least16_t": "int_least16_t",
    "c_int_least32_t": "int_least32_t",
    "c_int_least64_t": "int_least64_t",
    "c_int_least128_t": "int_least128_t",
    "c_int_fast8_t": "int_fast8_t",
    "c_int_fast16_t": "int_fast16_t",
    "c_int_fast32_t": "int_fast32_t",
    "c_int_fast64_t": "int_fast64_t",
    "c_int_fast128_t": "int_fast128_t",
    "c_intmax_t": "intmax_t",
    "c_intptr_t": "intptr_t",
    "c_ptrdiff_t": "ptrdiff_t"
  },
  "logical" : { 
    "": "bool",
    "c_bool": "bool"
  }
}
translator.FORTRAN_TYPE_2_BYTES_MAP = { # x86_64 
  "character": {
    "": "1",
    "c_char": "1"
  },
  "complex" : { 
    "":   "2*4",
    "16": "2*16",
    "8":  "2*8",
    "4":  "2*4",
    "2":  "2*2",
    "1":  "2*1",
    "c_float_complex": "2*4",
    "c_double_complex": "2*8",
    "c_long_double_complex": "2*16"
  },
  "doubleprecision" : {
    "":"8"
  },
  "real" : { 
    "": "4",
    "16": "16",
    "8": "8",
    "4": "4",
    "2": "2",
    "1": "1",
    "c_float": "4",
    "c_double": "8",
    "c_long_double": "16",
    "c_float128": "16",
    "c_float128_complex": "16"
  },
  "integer" : {
    "": "4",
    "8": "8",
    "4": "4",
    "2": "2",
    "1": "1",
    "c_int": "4",
    "c_short": "2",
    "c_long": "8",
    "c_long_long": "16",
    "c_signed_char": "1",
    "c_size_t": "8",
    "c_int8_t": "1",
    "c_int16_t": "2",
    "c_int32_t": "4",
    "c_int64_t": "8",
    "c_int128_t": "16",
    "c_int_least8_t": "1",
    "c_int_least16_t": "2",
    "c_int_least32_t": "4",
    "c_int_least64_t": "8",
    "c_int_least128_t": "16",
    "c_int_fast8_t": "1",
    "c_int_fast16_t": "8",
    "c_int_fast32_t": "8",
    "c_int_fast64_t": "8",
    "c_int_fast128_t": "16",
    "c_intmax_t": "8",
    "c_intptr_t": "8",
    "c_ptrdiff_t": "8"
  },
  "logical" : { 
    "": "1",
    "c_bool": "1"
  }
}
translator.LOOP_COLLAPSE_STRATEGY   = "collapse" # One of "collapse","collapse-always","grid"
# options for CUF
translator.CUBLAS_VERSION           = 1
---- fort2hip -----------------------------
fort2hip.LOG_PREFIX                 = "fort2hip.fort2hip"
        # Prefix for log output that this component writes.
fort2hip.FORTRAN_MODULE_PREAMBLE    = "" 
        # Preamble to write at the top of the generated Fortran module file.
fort2hip.FORTRAN_MODULE_SUFFIX      = "_fort2hip"
        # Suffix for generated hip modules.
fort2hip.FORTRAN_MODULE_FILE_EXT    = "-fort2hip.f08"
        # Suffix appended to the generated Fortran module.
fort2hip.HIP_FILE_EXT               = "-fort2hip.hip.cpp"
        # Suffix appended to the generated HIP C++ files.
fort2hip.GET_BLOCK_DIMS             = GET_DEFAULT_BLOCK_DIMS
        # Callback to provide default block dimensions for a given kernel.
        # callback arguments: kernel_name,filepath,lineno,dim
        # return: list of int with dim entries
fort2hip.GET_LAUNCH_BOUNDS          = GET_DEFAULT_LAUNCH_BOUNDS 
        # Callback to provide 'MAX_THREADS_PER_BLOCK, MIN_BLOCKS_PER_MP' for a given kernel.
        # callback arguments: kernel_name,filepath,lineno
        # return: a string consisting of two comma-separated integer numbers, e.g. '128,1' or '256, 4'
fort2hip.EMIT_KERNEL_LAUNCHER       = True  
        # Generate kernel launch routines that are callable from Fortran.
        # Set to 'False' in order to categorically disable generation of kernel launch routines.
fort2hip.EMIT_CPU_IMPLEMENTATION    = False 
        # Generate CPU kernel launch routines from Fortran loopnests. (EMIT_KERNEL_LAUNCHER must be set to True too.)
fort2hip.EMIT_DEBUG_CODE            = False 
        # Generate debug routine calls into the code that can be used 
        # to print out kernel argument values or device array elements and norms.
fort2hip.PRETTIFY_EMITTED_FORTRAN_CODE= False 
        # Prettify the emitted Fortran code with fprettify
fort2hip.PRETTIFY_EMITTED_C_CODE    = False  
        # Prettify the emitted HIP C++ code with clang-format.
fort2hip.CLANG_FORMAT_STYLE         = "\"{BasedOnStyle: llvm, ColumnLimit: 140, BinPackArguments: false, BinPackParameters: false, AllowAllArgumentsOnNextLine: false, AllowAllParametersOfDeclarationOnNextLine: false}\"" 
        # Format style that is passed to clang-format
---- indexer -----------------------------
# configurable parameters
indexer.LOG_PREFIX                  = "indexer.indexer"
indexer.DISCOVER_INPUT_FILES        = "find {search_dir} -type f -name \"*.*\" | grep \"\.[fF]\(90\|95\|77\)\?$\" | grep -v hipified"
indexer.FILTER_INPUT_FILES          = "grep -l \"{module_names}\" {input_files}"
indexer.PREPROCESS_FORTRAN_FILE     = "gfortran -cpp -E {options} {file} | grep -v \"^# [0-9]\""
indexer.STRUCTURES                  = r"module|program|function|routine|procedure|subroutine|interface|type|(end\s*(module|program|function|subroutine|interface|type))"
indexer.DECLARATIONS                = r"integer|real|double|logical" # derived types already considered by STRUCTURES
indexer.ATTRIBUTES                  = r"attributes"                    
indexer.USE                         = r"use"
indexer.DIRECTIVES                  = r"([!c\*]\$\w+)"
indexer.FILTER                      = r"\b("+STRUCTURES+"|"+DECLARATIONS+"|"+ATTRIBUTES+"|"+USE+r")\b"+"|"+DIRECTIVES
indexer.CONTINUATION_FILTER         = r"(\&\s*\n)|(\n\s*[\!c\*]\$\w+\&)"
indexer.PRETTY_PRINT_INDEX_FILE     = False # Pretty print index before writing it to disk.
indexer.PARSE_VARIABLE_DECLARATIONS_WORKER_POOL_SIZE= 1 # Number of worker threads for parsing variable declarations.
indexer.PARSE_VARIABLE_MODIFICATION_STATEMENTS_WORKER_POOL_SIZE= 1 # Number of worker threads for parsing statements that modify variable index linemaps, e.g. CUDA Fortran attributes statements  or OpenACC acc declare directives.
---- scoper -----------------------------
scoper.LOG_PREFIX                   = "indexer.scoper"
scoper.ERROR_HANDLING               = "warn" # one of "warn","error"
scoper.MODULE_IGNORE_LIST           = [ # these modules are ignored when checking dependencies
 "cudafor",
 "cublas",
 "cusparse",
 "cusolver",
 "iso_c_binding",
 "iso_fortran_env"]
scoper.SCOPES                       = []    # Can be used to preload scopes
scoper.REMOVE_OUTDATED_SCOPES       = False # Set to false if you want to preload scopes via your config file
---- linemapper -----------------------------
linemapper.LOG_PREFIX               = "linemapper.linemapper" # prefix for logging
linemapper.PATTERN_LINE_CONTINUATION= r"([\&]\s*\n)|(\n[!c\*]\$\w+\&)" # line continuation pattern. The linemapper's preprocessor removes them.
linemapper.ERROR_HANDLING           = "strict"   # 'strict': program terminates with error. Otherwise, a warning is printed.
linemapper.USER_DEFINED_MACROS      = [] # manually add macro definitions: dicts with entries 'name' (str), 'args' (list of str), and 'subst' (str)
linemapper.ONLY_APPLY_USER_DEFINED_MACROS= False # Only apply user defined macros (incl. compiler options) and turn off other preprocessing (-> all code is active)
linemapper.INDENT_WIDTH_WHITESPACE  = 2 # number of indent chars if indentation uses whitespaces
linemapper.INDENT_WIDTH_TABS        = 1       # number of indent chars if indentation uses tabs
linemapper.DEFAULT_INDENT_CHAR      = ' '   # The default index char to use if no other char was detected (' ' or '\t').
linemapper.LINE_GROUPING_INCLUDE_BLANK_LINES= True
linemapper.LINE_GROUPING_WRAP_IN_IFDEF= False       # Introduce ifdef-else-endif preprocessor block around modified lines and keep the original in the else branch. 
linemapper.LINE_GROUPING_IFDEF_MACRO= "__GPUFORT" # Macro to use in the ifdef directive.

---- utils.logging -----------------------------
utils.logging.LOG_FORMAT            = "%(levelname)s: %(message)s" # log format; '$(<var>)s' are placeholders
utils.logging.LOG_DIR               = "/tmp/gpufort"               # directory for storing log files
utils.logging.LOG_DIR_CREATE        = True                         # create log dir if it does not exist
utils.logging.VERBOSE               = False                        # print to stderr too (w.r.t. to chosen log level)
utils.logging.LOG_FILTER            = None                         # a regular expression or string that a substring of the log output must match; set this value to None if no log filtering should be applied.
utils.logging.TRACEBACK             = False
